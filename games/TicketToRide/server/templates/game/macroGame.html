{% macro socketGame(prefix) %}
<script type="text/javascript">
    {% include "game/maps_images.js" %}

    var canvas = document.getElementById('game_canvas');
    var ctx = canvas.getContext('2d');

    var p1 = {};
    var p2 = {};

    /**
     * Draw a <color> rectangle centered on <pos>, and rotated <angle> degrees.
     **/
    function drawRectangle(pos, angle, color) {
        ctx.save();

        ctx.fillStyle = "black";
        ctx.translate(pos[0], pos[1]);
        ctx.rotate(angle * Math.PI / 180);
        ctx.fillRect(-7, -20, 13, 40);
        ctx.fillStyle = color;
        ctx.fillRect(-6, -19, 11 ,38);

        ctx.restore();
    }

    /* function run by Game.html and Player.html */
    function updateWebSocket(){
        /* when received update about a Game, just display it */
        socket.on('update{{ GameName }}', function (msg) {
            var data = JSON.parse(msg);

            // load image and get players names only first time
            if (data.hasOwnProperty('map_name')) {
                let map_bg = new Image();
                map_bg.onload = function () {
                    canvas.setAttribute("width", maps[data['map_name']].width);
                    canvas.setAttribute("height", maps[data['map_name']].height);
                    ctx.drawImage(map_bg, 0, 0, canvas.getAttribute('width'), canvas.getAttribute('height'));
                    // draw all rectangles (only for testing)
                    /*for (let key in data.coordinates.tracks) {
                        if (data.coordinates.tracks.hasOwnProperty(key)) {
                            let rect_list = data.coordinates.tracks[key];
                            for (let i = 0; i < rect_list.length; i++) {
                                let rect = rect_list[i];
                                drawRectangle(rect[0], rect[1], "green");
                            }
                        }
                    }*/
                    // draw already claimed tracks
                    for (let i = 0; i < data.p1.tracks.length; i++) {
                        for (let j = 0; j < data.p1.tracks[i].length; j++) {
                            let rect = data.p1.tracks[i][j];
                            drawRectangle(rect[0], rect[1], "blue");
                        }
                    }
                    for (let i = 0; i < data.p2.tracks.length; i++) {
                        for (let j = 0; j < data.p2.tracks[i].length; j++) {
                            let rect = data.p2.tracks[i][j];
                            drawRectangle(rect[0], rect[1], "red");
                        }
                    }
                }
                p1.name = data.p1.name;
                p2.name = data.p2.name;
                p1.wagons = data.p1.wagons;
                p2.wagons = data.p2.wagons;
                map_bg.src = maps[data['map_name']].data;
            }

            // a player claimed a track, draw it
            if (data.hasOwnProperty('claimed')) {
                console.log("track claimed by player ", data.claimed.player, data.claimed.track)
                let color = "blue";
                if (data.claimed.player === 0) {
                    p1.wagons -= data.claimed.track.length;
                }
                if (data.claimed.player === 1) {
                    color = "red"
                    p2.wagons -= data.claimed.track.length;
                }
                for (let i = 0; i < data.claimed.track.length; i++) {
                    drawRectangle(data.claimed.track[i][0], data.claimed.track[i][1], color);
                }
            }
            // update players wagons number
            document.getElementById('p1-info').innerHTML = p1.name+" has "+p1.wagons+" wagons.";
            document.getElementById('p2-info').innerHTML = p2.name+" has "+p2.wagons+" wagons.";

            // update comments
            let comments = document.getElementById('comments');
            comments.innerHTML += data['comments'];
            comments.scrollTop = comments.scrollHeight;
        });
    }
    /* register to endOfGame and display it when received*/
    function displayEndOfGame(){
        socket.on('endOfGame', function(msg){
            document.getElementById('endOfGame').innerHTML = msg;
        });
    }
</script>
{% endmacro %}

{% macro styleGame() %}
<style>
* {
    box-sizing: border-box;
}

#game_content {
    display: grid;
    grid-template-columns: 75% 25%
}

.p-info {
    padding: 20px;
    border: 2px solid;
    border-radius: 5px;
    margin-bottom: 15px;
}

#p1-info {
    border-color: blue;
}
#p2-info {
    border-color: red;
}
#comments {
    border: 2px solid #a9a9a9;
    border-radius: 5px;
    padding: 8px;
    height: 300px;
    overflow-y: scroll;
}
#comments::before{
    content: "Comments : ";
    display: block;
}

</style>
{% endmacro %}

{% macro contentGame() %}
<div id="game_content" style="padding: 25px 15px">
    <canvas style="display:block; margin: 0 auto; width: 95%;" id="game_canvas">
    </canvas>
    <div id="players-info">
        <div id="p1-info" class="p-info"></div>
        <div id="p2-info" class="p-info"></div>
        <div id="comments"></div>
    </div>
</div>
{% endmacro %}